<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>fix8: ff::ff_allocator Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="fix8_Logo_RGB_small.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">fix8
   &#160;<span id="projectnumber">version  1.0.0</span>
   </div>
   <div id="projectbrief">Open Source C++ FIX Framework</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classff_1_1ff__allocator.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classff_1_1ff__allocator-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ff::ff_allocator Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="classff_1_1ff__allocator.html" title="The ff_allocator, based on the idea of the Slab allocator">ff_allocator</a>, based on the idea of the <a href="http://www.ibm.com/developerworks/linux/library/l-linux-slab-allocator/" target="_blank">Slab allocator</a>  
 <a href="classff_1_1ff__allocator.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="allocator_8hpp_source.html">allocator.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for ff::ff_allocator:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classff_1_1ff__allocator.png" usemap="#ff::ff_allocator_map" alt=""/>
  <map id="ff::ff_allocator_map" name="ff::ff_allocator_map">
<area href="classff_1_1ffa__wrapper.html" alt="ff::ffa_wrapper" shape="rect" coords="0,56,95,80"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a8382d619374c20723c838afff6dc0585"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classff_1_1ff__allocator.html#a8382d619374c20723c838afff6dc0585">getslabs</a> (size_t size)</td></tr>
<tr class="separator:a8382d619374c20723c838afff6dc0585"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acba5de684b298cab52442281766157d2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classff_1_1ff__allocator.html#acba5de684b298cab52442281766157d2">ff_allocator</a> (size_t <a class="el" href="classff_1_1ff__allocator.html#aae500fc7d575aacfbb48326ef982b44f">max_size</a>=0, const int <a class="el" href="classff_1_1ff__allocator.html#ab4acffca209f242ece598bff4499ba9e">delayedReclaim</a>=0)</td></tr>
<tr class="memdesc:acba5de684b298cab52442281766157d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default Constructor.  <a href="#acba5de684b298cab52442281766157d2">More...</a><br/></td></tr>
<tr class="separator:acba5de684b298cab52442281766157d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9787a0f1539c6f0bd559c9ab4d98442"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classff_1_1ff__allocator.html#aa9787a0f1539c6f0bd559c9ab4d98442">~ff_allocator</a> ()</td></tr>
<tr class="separator:aa9787a0f1539c6f0bd559c9ab4d98442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4256355feee6ed6fd39a515da813fbcb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classff_1_1ff__allocator.html#a4256355feee6ed6fd39a515da813fbcb">init</a> (const int _nslabs[<a class="el" href="namespaceff.html#a891ee36906077e95b8dde7a62ff9ae10a9b057b825c2a8d1ab94ef55519344dd1">N_SLABBUFFER</a>]=0, bool prealloc=true)</td></tr>
<tr class="separator:a4256355feee6ed6fd39a515da813fbcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09e650148ba1d77a17015eb302808714"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classff_1_1ff__allocator.html#a09e650148ba1d77a17015eb302808714">registerAllocator</a> ()</td></tr>
<tr class="separator:a09e650148ba1d77a17015eb302808714"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc24fb135fae47a76d9c4581f7fe74ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classff_1_1ff__allocator.html#acc24fb135fae47a76d9c4581f7fe74ea">deregisterAllocator</a> (bool reclaimMemory=true)</td></tr>
<tr class="separator:acc24fb135fae47a76d9c4581f7fe74ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac09381e5eaa8279a60b7a191f2210174"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classff_1_1ff__allocator.html#ac09381e5eaa8279a60b7a191f2210174">register4free</a> ()</td></tr>
<tr class="separator:ac09381e5eaa8279a60b7a191f2210174"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a2419683448dabfa9803c171778e778"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classff_1_1ff__allocator.html#a8a2419683448dabfa9803c171778e778">malloc</a> (size_t size)</td></tr>
<tr class="separator:a8a2419683448dabfa9803c171778e778"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ad062e04d2c1739a089cbc0a60dda0b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classff_1_1ff__allocator.html#a3ad062e04d2c1739a089cbc0a60dda0b">posix_memalign</a> (void **memptr, size_t alignment, size_t size)</td></tr>
<tr class="separator:a3ad062e04d2c1739a089cbc0a60dda0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4fe08078fc1624b607c3a9fdd823350"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classff_1_1ff__allocator.html#ad4fe08078fc1624b607c3a9fdd823350">free</a> (void *<a class="el" href="MPMCqueues_8hpp.html#a7459053063c7e93f801434f6411b9dd2">ptr</a>)</td></tr>
<tr class="separator:ad4fe08078fc1624b607c3a9fdd823350"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fca2e9b8f44f74e27ac34725eb07d34"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classff_1_1ff__allocator.html#a7fca2e9b8f44f74e27ac34725eb07d34">realloc</a> (void *<a class="el" href="MPMCqueues_8hpp.html#a7459053063c7e93f801434f6411b9dd2">ptr</a>, size_t newsize)</td></tr>
<tr class="separator:a7fca2e9b8f44f74e27ac34725eb07d34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfe6df9263d9272bb39fb6b9be64f2a9"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classff_1_1ff__allocator.html#abfe6df9263d9272bb39fb6b9be64f2a9">growsup</a> (void *<a class="el" href="MPMCqueues_8hpp.html#a7459053063c7e93f801434f6411b9dd2">ptr</a>, size_t newsize)</td></tr>
<tr class="separator:abfe6df9263d9272bb39fb6b9be64f2a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:afc468587c5e275d40aaee05f432ba923"><td class="memItemLeft" align="right" valign="top"><a class="el" href="allocator_8hpp.html#a2fbd97af3a198200b674b6658fb90a50">ALLSTATS</a>(void printstats(std::ostream <br class="typebreak"/>
&amp;out){all_stats::instance() -&gt;<br class="typebreak"/>
print(out);}) private <br class="typebreak"/>
<a class="el" href="classff_1_1SegmentAllocator.html">SegmentAllocator</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classff_1_1ff__allocator.html#afc468587c5e275d40aaee05f432ba923">alloc</a></td></tr>
<tr class="separator:afc468587c5e275d40aaee05f432ba923"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae500fc7d575aacfbb48326ef982b44f"><td class="memItemLeft" align="right" valign="top">const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classff_1_1ff__allocator.html#aae500fc7d575aacfbb48326ef982b44f">max_size</a></td></tr>
<tr class="separator:aae500fc7d575aacfbb48326ef982b44f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4acffca209f242ece598bff4499ba9e"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classff_1_1ff__allocator.html#ab4acffca209f242ece598bff4499ba9e">delayedReclaim</a></td></tr>
<tr class="separator:ab4acffca209f242ece598bff4499ba9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a6fe7b7eef67f4bebfba3c705096a067d"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classff_1_1ff__allocator.html#a6fe7b7eef67f4bebfba3c705096a067d">free</a> (<a class="el" href="structff_1_1Buf__ctl.html">Buf_ctl</a> *buf)</td></tr>
<tr class="separator:a6fe7b7eef67f4bebfba3c705096a067d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1156e5f5142be9fa15d1b703e8032246"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classff_1_1ff__allocator.html#a1156e5f5142be9fa15d1b703e8032246">allocatedsize</a> ()</td></tr>
<tr class="separator:a1156e5f5142be9fa15d1b703e8032246"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a70b7d4612e01bb7b2de6cfddd46104e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structff_1_1Seg__ctl.html">Seg_ctl</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classff_1_1ff__allocator.html#a70b7d4612e01bb7b2de6cfddd46104e3">getsegctl</a> (<a class="el" href="structff_1_1Buf__ctl.html">Buf_ctl</a> *buf)</td></tr>
<tr class="separator:a70b7d4612e01bb7b2de6cfddd46104e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4adc34e5efa1f53d66a2f4eddcf40c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classff_1_1SlabCache.html">SlabCache</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classff_1_1ff__allocator.html#ad4adc34e5efa1f53d66a2f4eddcf40c4">getslabs</a> (<a class="el" href="structff_1_1Buf__ctl.html">Buf_ctl</a> *buf)</td></tr>
<tr class="separator:ad4adc34e5efa1f53d66a2f4eddcf40c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a90dcaed0c9c7a0dc2f18aaa9468cc743"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classff_1_1ff__allocator.html#a90dcaed0c9c7a0dc2f18aaa9468cc743">FFAllocator</a></td></tr>
<tr class="separator:a90dcaed0c9c7a0dc2f18aaa9468cc743"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="classff_1_1ff__allocator.html" title="The ff_allocator, based on the idea of the Slab allocator">ff_allocator</a>, based on the idea of the <a href="http://www.ibm.com/developerworks/linux/library/l-linux-slab-allocator/" target="_blank">Slab allocator</a> </p>
<p>The <a class="el" href="classff_1_1ff__allocator.html" title="The ff_allocator, based on the idea of the Slab allocator">ff_allocator</a> works over the <a class="el" href="classff_1_1SlabCache.html" title="Cache of slab segments.">SlabCache</a> and is tuned to outperform standard allocators' performance in a multi-threaded envirnoment. When it is initialised, it creates a (predefined) number of SlabCaches, each one containing a (predefined) number of buffers of different sizes, from 32 to 8192 bytes. The thread that calls first the allocator object and wants to allocate memory has to register itself to the shared leak queue. Only one thread can perform this operation. The allocator obtains memory from the pre-allocated <a class="el" href="classff_1_1SlabCache.html" title="Cache of slab segments.">SlabCache</a>: if there is a slab (i.e. a buffer) big enough to contain an object of the requested size, the pointer to that buffer is passed to the thread that requested the memory. This latter thread has to register as well to the same shared leak queue, so that when it has finished its operations, it can return memory to the allocator thread. </p>

<p>Definition at line <a class="el" href="allocator_8hpp_source.html#l00899">899</a> of file <a class="el" href="allocator_8hpp_source.html">allocator.hpp</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="acba5de684b298cab52442281766157d2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ff::ff_allocator::ff_allocator </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_size</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>delayedReclaim</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default Constructor. </p>
<p>TODO </p>

<p>Definition at line <a class="el" href="allocator_8hpp_source.html#l00988">988</a> of file <a class="el" href="allocator_8hpp_source.html">allocator.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa9787a0f1539c6f0bd559c9ab4d98442"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual ff::ff_allocator::~ff_allocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destructor </p>

<p>Definition at line <a class="el" href="allocator_8hpp_source.html#l00994">994</a> of file <a class="el" href="allocator_8hpp_source.html">allocator.hpp</a>.</p>

<p>References <a class="el" href="allocator_8hpp_source.html#l00872">ff::SlabCache::alloc</a>, and <a class="el" href="allocator_8hpp_source.html#l00218">ff::SegmentAllocator::~SegmentAllocator()</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a1156e5f5142be9fa15d1b703e8032246"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t ff::ff_allocator::allocatedsize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>TODO </p>

<p>Definition at line <a class="el" href="allocator_8hpp_source.html#l00972">972</a> of file <a class="el" href="allocator_8hpp_source.html">allocator.hpp</a>.</p>

<p>References <a class="el" href="allocator_8hpp_source.html#l00853">ff::SlabCache::allocatedsize()</a>.</p>

</div>
</div>
<a class="anchor" id="acc24fb135fae47a76d9c4581f7fe74ea"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ff::ff_allocator::deregisterAllocator </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reclaimMemory</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Deregister the allocator (i.e. stop asking for memory) and reclaim allocated memory back to the allocator. Every thread can perform this action.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reclaimMemory</td><td><code>true</code> if reclaim; <code>false</code> if deregister only </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="allocator_8hpp_source.html#l01090">1090</a> of file <a class="el" href="allocator_8hpp_source.html">allocator.hpp</a>.</p>

<p>References <a class="el" href="allocator_8hpp_source.html#l00745">ff::SlabCache::deregisterAllocator()</a>.</p>

<p>Referenced by <a class="el" href="allocator_8hpp_source.html#l01596">ff::FFAllocator::deleteAllocator()</a>, and <a class="el" href="allocator_8hpp_source.html#l01831">ff::FFAkeyDestructorHandler()</a>.</p>

</div>
</div>
<a class="anchor" id="a6fe7b7eef67f4bebfba3c705096a067d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool ff::ff_allocator::free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structff_1_1Buf__ctl.html">Buf_ctl</a> *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="structff_1_1Buf__ctl.html" title="A buffer controller.">Buf_ctl</a> type is a pointer to <a class="el" href="classff_1_1SlabCache.html" title="Cache of slab segments.">SlabCache</a> Frees the buffer <code>buf</code> and returns it to its slab segment</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if some memory has been reclaimed </dd></dl>

<p>Reimplemented in <a class="el" href="classff_1_1ffa__wrapper.html#ada3370f18adff1597c079ee64fb15329">ff::ffa_wrapper</a>.</p>

<p>Definition at line <a class="el" href="allocator_8hpp_source.html#l00962">962</a> of file <a class="el" href="allocator_8hpp_source.html">allocator.hpp</a>.</p>

<p>References <a class="el" href="allocator_8hpp_source.html#l00196">ALLSTATS</a>, <a class="el" href="allocator_8hpp_source.html#l00101">DBG</a>, and <a class="el" href="allocator_8hpp_source.html#l00821">ff::SlabCache::putitem()</a>.</p>

<p>Referenced by <a class="el" href="allocator_8hpp_source.html#l01348">ff::ffa_wrapper::free()</a>.</p>

</div>
</div>
<a class="anchor" id="ad4fe08078fc1624b607c3a9fdd823350"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ff::ff_allocator::free </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Custom <code>ff</code> free.<br/>
 It frees a buffer (slab) of the <a class="el" href="classff_1_1SlabCache.html" title="Cache of slab segments.">SlabCache</a> pointed by <code>ptr</code>. Not only it frees the memory but also takes care of the correct positioning of pointers within the <a class="el" href="classff_1_1SlabCache.html" title="Cache of slab segments.">SlabCache</a> structures, in order to maintain the integrity of the cache and avoid fragmentation.<br/>
 WARNING: this function might fail if memory has been previously allocated using the posix_memalign method with a size grater than MAX_SLABBUFFER_SIZE</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>a pointer to the buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TODO </dd></dl>

<p>Definition at line <a class="el" href="allocator_8hpp_source.html#l01226">1226</a> of file <a class="el" href="allocator_8hpp_source.html">allocator.hpp</a>.</p>

<p>References <a class="el" href="allocator_8hpp_source.html#l00196">ALLSTATS</a>, and <a class="el" href="allocator_8hpp_source.html#l00299">ff::Buf_ctl::ptr</a>.</p>

</div>
</div>
<a class="anchor" id="a70b7d4612e01bb7b2de6cfddd46104e3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structff_1_1Seg__ctl.html">Seg_ctl</a>* ff::ff_allocator::getsegctl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structff_1_1Buf__ctl.html">Buf_ctl</a> *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>TODO </p>

<p>Definition at line <a class="el" href="allocator_8hpp_source.html#l00940">940</a> of file <a class="el" href="allocator_8hpp_source.html">allocator.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8382d619374c20723c838afff6dc0585"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ff::ff_allocator::getslabs </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check if there is a slab big enough to contain an object as big as <code>size</code>.</p>
<p>Since there is a limited number of possible slab sizes, and these predefined dimensions are all powers of 2, it is easy to find which slub can contain the object of the given size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>the size of the object that must be contained in a slab.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the object can be contained in the slab of the smallest size </dd>
<dd>
the index of the suitable slab size in the array of possible sizes, if one exists </dd>
<dd>
-1 if the object is too big to be contained in one of the slabs. </dd></dl>

<p>Definition at line <a class="el" href="allocator_8hpp_source.html#l00919">919</a> of file <a class="el" href="allocator_8hpp_source.html">allocator.hpp</a>.</p>

<p>References <a class="el" href="allocator_8hpp_source.html#l00114">ff::POW2_MAX</a>, <a class="el" href="allocator_8hpp_source.html#l00113">ff::POW2_MIN</a>, and <a class="el" href="allocator_8hpp_source.html#l00858">ff::SlabCache::size</a>.</p>

</div>
</div>
<a class="anchor" id="ad4adc34e5efa1f53d66a2f4eddcf40c4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classff_1_1SlabCache.html">SlabCache</a>* ff::ff_allocator::getslabs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structff_1_1Buf__ctl.html">Buf_ctl</a> *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>TODO </p>

<p>Definition at line <a class="el" href="allocator_8hpp_source.html#l00947">947</a> of file <a class="el" href="allocator_8hpp_source.html">allocator.hpp</a>.</p>

<p>References <a class="el" href="allocator_8hpp_source.html#l00445">ff::SlabCache::getsegctl()</a>.</p>

</div>
</div>
<a class="anchor" id="abfe6df9263d9272bb39fb6b9be64f2a9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* ff::ff_allocator::growsup </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>newsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>It is like realloc but it doesn't copy data</p>
<p>ptr TODO  newsize TODO</p>
<dl class="section return"><dt>Returns</dt><dd>TODO </dd></dl>

<p>Definition at line <a class="el" href="allocator_8hpp_source.html#l01288">1288</a> of file <a class="el" href="allocator_8hpp_source.html">allocator.hpp</a>.</p>

<p>References <a class="el" href="allocator_8hpp_source.html#l00196">ALLSTATS</a>, <a class="el" href="allocator_8hpp_source.html#l00850">ff::SlabCache::getsize()</a>, <a class="el" href="allocator_8hpp_source.html#l00299">ff::Buf_ctl::ptr</a>, <a class="el" href="MPMCqueues_8hpp_source.html#l00676">ptr</a>, and <a class="el" href="allocator_8hpp_source.html#l00821">ff::SlabCache::putitem()</a>.</p>

<p>Referenced by <a class="el" href="allocator_8hpp_source.html#l01415">ff::ffa_wrapper::growsup()</a>.</p>

</div>
</div>
<a class="anchor" id="a4256355feee6ed6fd39a515da813fbcb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ff::ff_allocator::init </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>_nslabs</em>[N_SLABBUFFER] = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>prealloc</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initialise the allocator. This method is called by one thread for each data-path. (e.g. the Emitter in a Farm skeleton). <br/>
 It creates a number of SlabCaches objects, a number specified by the <code>N_SLABBUFFER</code> constant. The size of each created segment goes from 32 (the first one created) to 8192 (the last).<br/>
 Note that, unless otherwise specified, the number of buffers in a slab segment decreases as the size of the slab increases.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_nslabs</td><td>an array specifying the allowed numbers of buffers in a <a class="el" href="classff_1_1SlabCache.html" title="Cache of slab segments.">SlabCache</a>. By default it is initialised to 0s </td></tr>
    <tr><td class="paramname">prealloc</td><td>flag used when creating new SlabCaches. Default is <code>true</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if initialisation succedes; a negative value otherwise </dd></dl>
<p>Allocate space for a SegmenAllocator object and initialise it.</p>
<p>Allocate space for 'N_SLABBUFFER' caches and create <a class="el" href="classff_1_1SlabCache.html" title="Cache of slab segments.">SlabCache</a> objects. Buffers size within a cache size grows from 32 to 8192. if not otherwise specified, the number of slab buffers in a segment decreases as the size of the slab increases.</p>

<p>Definition at line <a class="el" href="allocator_8hpp_source.html#l01025">1025</a> of file <a class="el" href="allocator_8hpp_source.html">allocator.hpp</a>.</p>

<p>References <a class="el" href="allocator_8hpp_source.html#l00872">ff::SlabCache::alloc</a>, <a class="el" href="allocator_8hpp_source.html#l00117">ff::buffersize</a>, <a class="el" href="allocator_8hpp_source.html#l00874">ff::SlabCache::delayedReclaim</a>, <a class="el" href="utils_8hpp_source.html#l00119">ff::error()</a>, <a class="el" href="allocator_8hpp_source.html#l00679">ff::SlabCache::init()</a>, <a class="el" href="allocator_8hpp_source.html#l00112">ff::N_SLABBUFFER</a>, <a class="el" href="allocator_8hpp_source.html#l00859">ff::SlabCache::nslabs</a>, <a class="el" href="allocator_8hpp_source.html#l00124">ff::nslabs_default</a>, <a class="el" href="svector_8hpp_source.html#l00157">ff::svector&lt; T &gt;::push_back()</a>, and <a class="el" href="allocator_8hpp_source.html#l00634">ff::SlabCache::SlabCache()</a>.</p>

<p>Referenced by <a class="el" href="allocator_8hpp_source.html#l01475">ff::FFAllocator::newAllocator()</a>.</p>

</div>
</div>
<a class="anchor" id="a8a2419683448dabfa9803c171778e778"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* ff::ff_allocator::malloc </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Custom <code>ff</code> malloc.</p>
<p>Requests to allocate <code>size</code> bytes of dynamic memory. If the requested size is bigger than the maximum size for a buffer OR there are no more free buffers in the existing SlabCaches, a new chunk of dynamic memory is allocated. The size of the allocated chunk is equal to the size requested.</p>
<p>Otherwise it returns a pointer to an available buffer in the slabs cache that fits the requested size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>the size of memory requested</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TODO </dd></dl>
<p>use standard allocator if the size is too big or we don't want to use the <a class="el" href="classff_1_1ff__allocator.html" title="The ff_allocator, based on the idea of the Slab allocator">ff_allocator</a> for that size</p>

<p>Definition at line <a class="el" href="allocator_8hpp_source.html#l01135">1135</a> of file <a class="el" href="allocator_8hpp_source.html">allocator.hpp</a>.</p>

<p>References <a class="el" href="allocator_8hpp_source.html#l00196">ALLSTATS</a>, <a class="el" href="allocator_8hpp_source.html#l00101">DBG</a>, <a class="el" href="allocator_8hpp_source.html#l00852">ff::SlabCache::getnslabs()</a>, <a class="el" href="allocator_8hpp_source.html#l00112">ff::MAX_SLABBUFFER_SIZE</a>, and <a class="el" href="MPMCqueues_8hpp_source.html#l00676">ptr</a>.</p>

<p>Referenced by <a class="el" href="allocator_8hpp_source.html#l01383">ff::ffa_wrapper::malloc()</a>.</p>

</div>
</div>
<a class="anchor" id="a3ad062e04d2c1739a089cbc0a60dda0b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ff::ff_allocator::posix_memalign </td>
          <td>(</td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>memptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Custom <code>ff</code> posix_memalign. <br/>
 Like the custom malloc, but it returns a pointer to an aligned chunk of memory.</p>
<p>, **memptr pointer to a chunk of memory where the aligned memory will be returned.  alignment the returned memory will be a multiple of alignment, which must be a power of two and a multiple of sizeof(void  *). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>the size of memory requested.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TODO </dd></dl>

<p>Definition at line <a class="el" href="allocator_8hpp_source.html#l01170">1170</a> of file <a class="el" href="allocator_8hpp_source.html">allocator.hpp</a>.</p>

<p>References <a class="el" href="allocator_8hpp_source.html#l00196">ALLSTATS</a>, <a class="el" href="allocator_8hpp_source.html#l00101">DBG</a>, <a class="el" href="allocator_8hpp_source.html#l00852">ff::SlabCache::getnslabs()</a>, <a class="el" href="allocator_8hpp_source.html#l00200">ff::isPowerOfTwoMultiple()</a>, <a class="el" href="allocator_8hpp_source.html#l00112">ff::MAX_SLABBUFFER_SIZE</a>, <a class="el" href="allocator_8hpp_source.html#l00299">ff::Buf_ctl::ptr</a>, and <a class="el" href="MPMCqueues_8hpp_source.html#l00676">ptr</a>.</p>

<p>Referenced by <a class="el" href="allocator_8hpp_source.html#l01394">ff::ffa_wrapper::posix_memalign()</a>.</p>

</div>
</div>
<a class="anchor" id="a7fca2e9b8f44f74e27ac34725eb07d34"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* ff::ff_allocator::realloc </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>newsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Custom <code>ff</code> realloc. <br/>
 It changes the size of the memory block pointed to by <code>ptr</code> to <code>newsize</code> bytes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>pointer to the buffer. </td></tr>
    <tr><td class="paramname">newsize</td><td>the new size.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TODO </dd></dl>

<p>Definition at line <a class="el" href="allocator_8hpp_source.html#l01253">1253</a> of file <a class="el" href="allocator_8hpp_source.html">allocator.hpp</a>.</p>

<p>References <a class="el" href="allocator_8hpp_source.html#l00196">ALLSTATS</a>, <a class="el" href="allocator_8hpp_source.html#l00850">ff::SlabCache::getsize()</a>, <a class="el" href="allocator_8hpp_source.html#l00299">ff::Buf_ctl::ptr</a>, <a class="el" href="MPMCqueues_8hpp_source.html#l00676">ptr</a>, and <a class="el" href="allocator_8hpp_source.html#l00821">ff::SlabCache::putitem()</a>.</p>

<p>Referenced by <a class="el" href="allocator_8hpp_source.html#l01408">ff::ffa_wrapper::realloc()</a>.</p>

</div>
</div>
<a class="anchor" id="ac09381e5eaa8279a60b7a191f2210174"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ff::ff_allocator::register4free </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Threads different from the allocator (i.e. those threads that do not allocate memory) have to register themselves to the shared buffer by calling this method. In this way they are provided with a chunk of memory. Since they are registered, once their taks terminates they free the memory assigned and that memory returns back to the allocator thread's buffer, so that it can be reused.</p>
<dl class="section return"><dt>Returns</dt><dd>TODO </dd></dl>

<p>Definition at line <a class="el" href="allocator_8hpp_source.html#l01109">1109</a> of file <a class="el" href="allocator_8hpp_source.html">allocator.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a09e650148ba1d77a17015eb302808714"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ff::ff_allocator::registerAllocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The thread that allocates memory have to call this method in order to register itself to the shared buffer. With this method, a thread is allowed to allocate memory. Only one thread can allocate memory.</p>
<dl class="section return"><dt>Returns</dt><dd>0 if operation succedes, -1 otherwise </dd></dl>

<p>Definition at line <a class="el" href="allocator_8hpp_source.html#l01074">1074</a> of file <a class="el" href="allocator_8hpp_source.html">allocator.hpp</a>.</p>

<p>Referenced by <a class="el" href="allocator_8hpp_source.html#l01475">ff::FFAllocator::newAllocator()</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="a90dcaed0c9c7a0dc2f18aaa9468cc743"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classff_1_1FFAllocator.html">FFAllocator</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="allocator_8hpp_source.html#l00900">900</a> of file <a class="el" href="allocator_8hpp_source.html">allocator.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="afc468587c5e275d40aaee05f432ba923"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="allocator_8hpp.html#a2fbd97af3a198200b674b6658fb90a50">ALLSTATS</a> ( void printstats(std::ostream &amp; out) { all_stats::instance()-&gt;print(out); } ) private <a class="el" href="classff_1_1SegmentAllocator.html">SegmentAllocator</a>* ff::ff_allocator::alloc</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="allocator_8hpp_source.html#l01311">1311</a> of file <a class="el" href="allocator_8hpp_source.html">allocator.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab4acffca209f242ece598bff4499ba9e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int ff::ff_allocator::delayedReclaim</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="allocator_8hpp_source.html#l01319">1319</a> of file <a class="el" href="allocator_8hpp_source.html">allocator.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aae500fc7d575aacfbb48326ef982b44f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const size_t ff::ff_allocator::max_size</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="allocator_8hpp_source.html#l01318">1318</a> of file <a class="el" href="allocator_8hpp_source.html">allocator.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="allocator_8hpp_source.html">allocator.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->

    <li class="footer"><a href=http://www.fix8.org><b>fix8</b></a> documentation generated on Thu Jan 16 2014 16:13:41. Copyright &copy; 2010-14, <a href=mailto:fix@fix8.org><b>The Fix8 Team.</b></a> All rights reserved.</li>
   </ul>
 </div>
</body>
</html>
